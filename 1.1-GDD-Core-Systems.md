# GDTLancer - Core Systems (Phase 1)

**Version:** 1.5
**Date:** October 31, 2025
**Related Documents:** 0.1-GDD-Main.md (v1.9), 5.1-GDD-Module-Piloting.md (v1.6), 5.2-GDD-Module-Combat.md (v1.4), 5.3-GDD-Module-Trading.md (v1.1)

## 1. Overview

This document defines the core, cross-cutting gameplay systems required to support the Phase 1 modules (Piloting, Combat, Trading). The definitions and terminology herein are designed to align with the existing project codebase to ensure consistency between design and implementation. All systems listed are located within the `/core/systems/` directory and are added as children to the `WorldManager` node in `main_game_scene.tscn`.

*Note: The `EventBus` is an autoload script (`autoload/EventBus.gd`) used for managing engine-level signals. It is a core piece of the architecture but is not a gameplay system in the same vein as those listed below.*

## 2. System Definitions

### System 1: Event System
* **Code Reference:** `core/systems/event_system.gd`
* **Core Responsibility:** To act as a narrative and world event "oracle." It generates and triggers in-game events based on the passage of Time Units (TU), player actions, and other dynamic world states. These are high-level gameplay events (e.g., an ambush, a market opportunity, a distress call), not to be confused with low-level engine signals handled by the `EventBus`.

### System 2: Time System
* **Code Reference:** `core/systems/time_system.gd`
* **Core Responsibility:** To manage the passage of abstract game time (`Time Units` or `TU`) and its consequences.
* **Phase 1 Functionality:**
    * Operates on the global `GameState.current_tu` variable.
    * Must provide a function `add_time_units(tu_to_add: int)`.
    * When `GameState.current_tu` reaches `Constants.TIME_CLOCK_MAX_TU`, it must:
        1.  Emit a `world_event_tick_triggered` signal on the `EventBus`.
        2.  Call the `Character System` to deduct the periodic `WP` Upkeep cost.
        3.  Decrement `GameState.current_tu` (handling multiple ticks if necessary).
* **Interactions:**
    * **Interacts With:**
        * `Piloting Module`: Free Flight mode will call the function to add `TU`.
        * `Trading Module`: Actions like `Seek Rare Goods` will add `TU`.
        * `Character System`: To apply the `WP` Upkeep cost.
        * `EventBus`: To announce the `World Event Tick`.

### System 3: Character System
* **Code Reference:** `core/systems/character_system.gd`
* **Core Responsibility:** To track and manage the core narrative stats, skills, and social standing for all character agents by providing a stateless API to access `GameState.characters`.
* **Phase 1 Functionality:**
    * Must provide functions to get character data (e.g., `get_player_character()`).
    * Must provide functions to safely add or subtract `WP` and `FP` from a character's data in `GameState` (e.g., `add_wp(uid, amount)`, `get_fp(uid)`).
    * Must provide a function to retrieve skill values (e.g., `get_skill_level(uid, skill_name)`).
    * Must provide a function to handle the `Upkeep Cost` deduction (e.g., `apply_upkeep_cost(uid, cost)`) when called by the `Time System`.
* **Interactions:**
    * **Interacts With:**
        * `Trading Module`: To modify a character's `WP` total.
        * `Combat/Piloting Modules`: To retrieve skill values for `Module Modifiers`.
        * `Time System`: Receives the call to deduct `WP` for upkeep.
        * `GameStateManager`: Provides character data for saving and loading.

### System 4: Inventory System
* **Code Reference:** `core/systems/inventory_system.gd`
* **Core Responsibility:** To manage the contents of all character inventories within `GameState.inventories`. It is a stateless API.
* **Phase 1 Functionality:**
    * Must define the `InventoryType` enum (`SHIP`, `MODULE`, `COMMODITY`).
    * Must provide a function to create a new inventory record for a character: `create_inventory_for_character(uid)`.
    * Must provide generic functions to add/remove assets: `add_asset(uid, type, asset_id, quantity)` and `remove_asset(uid, type, asset_id, quantity)`.
    * Must provide a function to check quantity: `get_asset_count(uid, type, asset_id)`.
* **Interactions:**
    * **Interacts With:**
        * `Trading Module`: The Trade Interface will call this system's functions to modify inventories. `Cargo Capacity` checks must be performed by the *Trading Module* (by querying the `Asset System`) *before* calling `add_asset`.
        * `WorldGenerator`: Calls `create_inventory_for_character(uid)`.

### System 5: Asset System
* **Code Reference:** `core/systems/asset_system.gd`
* **Core Responsibility:** To provide a stateless API for accessing master asset instances (like ships) stored in `GameState.assets_ships`.
* **Phase 1 Functionality:**
    * Must provide a function to retrieve a specific ship instance: `get_ship(ship_uid)`.
    * Must provide a convenience function to get the player's active ship (by checking `GameState.characters`): `get_player_ship()`.
    * The returned `ShipTemplate` resource contains all relevant stats (e.g., `cargo_capacity`, `hull_integrity`, `ship_quirks`).
* **Interactions:**
    * **Interacts With:**
        * `Inventory System`: Provides `Cargo Capacity` via `get_player_ship().cargo_capacity`.
        * `Combat Module`: Provides stats like `hull_integrity` from the `ShipTemplate`.
        * `Piloting Module`: Provides stats like `max_move_speed` from the `ShipTemplate`.

*Note on Core Mechanics API: The foundational dice roll logic is located in the `autoload/CoreMechanicsAPI.gd` autoload, which provides the `perform_action_check()` function.*
